import re


# print(re.findall('ab', 'cd123'))
# 没有与之匹配的就输出返回一个空列表
# 原本你你给一个字符串然后在你对于给出的字符串中查找，查找然后返回对应的列表


# 字符集
# 预定义字符，前面用一个’\‘表示这些字符本身不去匹配，而是这些字符对应的类型去匹配
# \D 非数字
# \d 匹配整数
# \S 匹配非打印字符串
# \s 匹配打印字符串
# \W 匹配非字母、数字、下划线
# \w 匹配字母、数字、下划线

print(re.findall(r'\D', 'abcd123456'))  # \D代表任意非数字

print(re.findall('[0-9]', 'abcd123456'))
print(re.findall('[^0-9]', 'abcd123456'))  # 加上^代表是这个的对立面，除了0-9全匹配
print(re.findall('\D', 'abcd123456'))


# 限定符
# 一般输出的序列都是一个字符占一个位置，想要一个位置上一个字符串怎么办
#  + 重复前面一个匹配字符一次或多次（至少一次）
#  * 重复前面一个匹配字符零次或多次
print(re.findall(r'ab+', 'ababa111abb1111'))
# +至少一次，从ab开始abb到abbb...都可以匹配
print(re.findall(r'ab*', 'ababa111abb1111'))
# *可以0次 所以当b没有的时候就是a然后ab然后abb，abbb....
# .匹配出\n以外的任一单个字符
print(re.findall(r'a.b', 'a+ba\nba\tb'))
# 只有对应的a\nb不输出，当.和\n重合时是不匹配的

# ？ 匹配前面一个字符的0个或者1个（只有0和1）
print(re.findall(r'ab?', 'a'))  # 0个的情况
print(re.findall(r'ab?', 'abbb')) # 一个的情况

# {数字} 可以前一个字符指定匹配次数（a{2}就是aa）
print(re.findall(r'a{2}', 'aaaaaa'))


# 正则表达式的表达形式（就是这么表示你想要进行匹配的字符）
# 有些元字符（\d什么的+还有.）
# 我们可能想把它们转化成普通字符匹配
# 这个还是用\来进行转换
print(re.findall(r'\d+\d', '1+6'))  # 这里的+就是元字符代表匹配一个或多个/d
print(re.findall(r'\d\+\d', '1+6'))  # 这里的/+就是普通字符代表+

# 原生字符串
# 可以注意到我想要找的字符串前面都会加一个r‘想要找的字符串’
# 那么这个r代表啥？
# 这个r就代表后面跟着的是原生字符串，那么里面的\字符就不在表示转义字符的含义，用来处理路径问题
# 像‘c:\now\ow’,这样的路径\n会识别成转义字符，而如果在前面+一个r
# 变为r'c:\now\ow'那就不会出现这样的错误了
# 如果不使用，也会使查找更加繁琐
# 比如你想匹配一个带\的字符怎么表示？
# 注意奥，正则表达式是有两层转义等着你的，第一层是python中转义，第二层是正则表达式中的转义
# 比如你想匹配一个\c你需要\\\\c这样写
# 先进行python中的转义：一个\\代表一个\
# 进行完python中转义的结果是\\c然后进行正则表达式转义
# \\变成\
# 匹配的就是\c喽
# 而使用r‘’原生字符的话，会默认其在python中的已经转义了
# 只需要进行对应的正则表达式的转义
text = 'apple\c'
print(re.search('\\\\c', text))
print(re.search(r'\\c', text))  # 只需要进行对应正则表达式的转义\\变为\

# 疑问1




