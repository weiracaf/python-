def f(a, b, c):
    print(a, b, c)


f(1, 2, 3)
# 位置参数，对应位置赋给对应的参数

# 关键字参数
f(c=1, b=2, a=3)


# 就是调用是还进行形参与实参的关联赋值
# 可以无视参数位置


def d(a, b=2, c=3):  # 默认参数就是给形参直接赋值
    print(a, b, c)


d(1)  # 如果你直接调用不写参数就会直接按照默认参数，默认参数可以有一个或多个


# 只能是从后面开始有默认参数
# 像def f（a=1,b=2,c）这样不行，因为你输入参数肯定是从第一个开始输啊
# 那你最后那个又没有默认参数，你只输入一个数肯定不行
# 只能说从后到前，有默认参数到没有例如这里的d

# 参数的混搭
def a_(a, *, b, c):
    print(a, b, c)


# *前面可以使用位置参数也可以使用关键字参数，*后面的参数必须要用关键字参数
# 类似的还有,/,表示/前面必须使用位置参数，/后面可以位置可以关键字
f(1, b=4, c=5)


def sum2(num1, num2):
    print("%d+%d=%d" % (num1, num2, num1 + num2))


sum2(10, 20)


# 可变参数
# 通过在参数前加一个*号，代表这个参数是可变参数，那么就可以输入任意个数的变量
# 返回是一个元组奥
def c_(*args):  # *代表解包，可以解包任意可迭代对象，但是默认的话是元组解包
    print(args)  # 什么叫默认元组就是你参数是一个*args，你传入的是解包后的状态，那么解包之前是什么可迭代对象呢？，python中是元组，这一步也可以叫做打包成元组


c_(1, 2, 3, 4, 5)  # *args=1, 2, 3, 4, 5
# 说明args是一个元组呗，元素就是12345
print(*[1, 2, 3])  # 解包
c_([1, 2, 3], [1, 2])  # 打包，*args=[1, 2, 3],则args=([1, 2, 3],[1, 2])
c_([1, 2, 3])  # 这里的输出会是（[1, 2, 3],）后面多个逗号，这样的形式才代表元组，那为什么会加个逗号呢？
# 本来就知道*不是解包吗，所以本来形式是个元组，什么元组解包是[1,2,3]
# 就是（【1,2,3】,）这个代表一个元素的元组，而不是（【1,2,3】）这个代表序列
print(type(([1, 2, 3])))  # 可以发现奥这里尽管我（【1,2,3】）这样的形式他是代表list的不是元组
print(type(([1, 2, 3],)))  # 这里就是元组了,后面加了个逗号


# 所以！，元组中有一个元素的时候需要在后面＋一个逗号


def q_(**a):  # 用字典的形式输入参数,跟上面的*其实差不多，就是**是固定解包字典的
    print(a['no1'])     # **a为no1=1,no2=2则a就是{no1=1,no2=2}呗,可以接收任意个关键字参数（可以不传参）
    print(a['no2'])
    print(a)


q_(no1=1, no2=2)


def foo(n, *args, **kwargs):
    print("n=", n, "*args=", args, "**kwargs=", kwargs)


foo(10, 23, 45, name="tom", age=23)


